calcPi1 :: Int -> Double

calcPi1 n = sum(take n ts)
    where 
        ns = cycle [4, -4]
        ds = [1,3 ..]
        ts = zipWith (/) ns ds

calcPi2 :: Int -> Double

calcPi2 n = 3 + sum (take n ts)
    where
        ns = cycle [4, -4]
        ds = [(2*k+2)*(2*k+3)*(2*k+4) | k <- [0..]]
        ts = zipWith (/) ns ds

{-
ns alternates between 4 and -4, just like in calcPi1.

ds builds the sequence of denominators: 2×3×4, 4×5×6, 6×7×8, etc.

zipWith (/) ns ds combines numerators and denominators into the term list.

fromIntegral is not necessary

Finally, we sum the first n terms and add 3 (since the series starts at 3).

-}

-- 4.2)

-- twin primes are pairs of consecutive prime numbers such that b = a + 2

-- ex: (3,5) and (5,7)

twinPrimes :: [(Integer, Integer)]
twinPrimes = [(p,q) | (p, q) <- zip primes(tail primes), q - p == 2] -- zip primes (tail primes) pairs each primes with the next one 

-- q - p == 2, filters only those pairs where the difference is 2

primes :: [Integer]
primes = sieve [2..] -- gives an infinite list of all prime numbers

sieve :: [Integer] -> [Integer]
sieve (p:xs) = p : sieve [x | x <- xs, x`mod`p /=0] 

-- 4.3)
{-
Hamming numbers are generated by starting at 1 and multiplying by 2,3 or 5

2^i x 3^j x 5^k~

why [2^i * 3^j * 5^k | i <- [0..], j <- [0..], k <- [0..]] doesn't work:
haskell tries to enumerate all j and k values for the first i = 0 before moving to i = 1,
meaning since j and k both go to infinity, the first level (i=0) never ends

-}

hammingForSum :: Int -> [Integer]
hammingForSum n = [2^i * 3^j * 5^k | i <- [0..n], j <- [0..(n - i)], let k = n - i - j]


hamming :: [Integer]
hamming = concat [hammingForSum n | n <- [0..]]

-- 4.4)

-- a)
merge :: [Integer] -> [Integer] -> [Integer]

merge (x:xs) (y:ys)
    | x < y = x : merge xs (y:ys)
    | x > y = y : merge (x:xs) ys
    | otherwise = x : merge xs ys

{-It only works for infinite lists, if we want to add for finite lists, we need to add a base case where the list is empty-}

-- b)
{-
The goal is to define an infinite list that contains all numbers whose only prime factors are 2,3 and 5
-}

hamming2 :: [Integer] 
hamming2 = 1 : merge (map (2*) hamming2) -- gives all numbers that are twice a Hamming number
                (merge (map (3*) hamming2) -- gives all numbers that are triple a Hamming number
                     (map(5*) hamming2)) -- gives all numbers that are five timeas a Hamming number

-- 4.5)
-- a)

rot13 :: 